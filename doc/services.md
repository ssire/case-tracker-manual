# Services Integration

The *services* library supports token secured inter-exchange of XML messages between a Case Tracker and other modules such as a poll application to complete feedback questionnaires or a coach match module to find experts to assist for a case. It is implemented by a `lib/services.xqm` XQuery module.

## Definitions

A service is a resource or controller which can be called using a specific **service protocol**. That resource or controller is called the **service endpoint**. The application hosting the service endpoint is called the **service producer**, while the application invoking the service is called the **service consumer**.

    (Application A) consumer end-point  <--- service protocol (XML message) ---> producer end-point (Application B)

The service protocol allows to POST a request with XML payload to a **service endpoint** and to receive an XML response.

The service protocol is configured in `services.xml` of both the service producer and service consumer.

The service protocol supports an optional authorization token. When configured it will restrict service invocation to requests containing the correct token configured in both the provider and the consumer.

## Configuration of the service protocol

The service configuration starts with a `Services` root element containing a `Providers` and a `Consumers` sections. Each section can be empty, or contain an indefinite number of `Service` elements which in turns contain an indefinite number of `EndPoint` elements. The configuration can also contain a top-level `Hooks` section which in turns can contain an indefinite number of services configuration. 

The self-describing skeleton of a *services.xml* file looks like the following one (a star * indicate 0 or more repetitions and a ? 0 or one) :

```xml
<Services>
  <Providers> ?
    <Service> *
      <Id>service identifier</Id>
      <Name Lang="en">localized service name</Name>
      <AuthorizationToken>AUTHORIZATION-TOKEN</AuthorizationToken>
      <EndPoint> *
        <Id>endpoint identifier</Id>
        <Name Lang="en">localized endpoint name</Name>
      </EndPoint>
    </Service>
  </Providers>
  <Consumers> ?
    <Service> *
      ... same as above...
      <EndPoint> *
        <Id>end point identifier</Id>
        <Name Lang="en">localized endpoint name</Name>
        <URL>... end point URL to invoke service....</URL>
      </EndPoint>
    </Service>
  </Consumers>
  <Hooks> ?
    <Service> *
    ... same as above w/o AuthorizationToken...
    </Service>
  </Hooks>
</Services>
```

### The `Service` element

The mandatory `Id` element defines the service name that identifies the service when calling a service API function. This name must be unique in the consumer and producer applications scope.

The `Name` element is used to identify the service in error messages generated by the service module.

The optional authorization token is the shared key that must be present both in the service producer and in the service consumer configurations. Both applications must be *paired* by editing their service configuration file right after deployment and you should be careful not to overwrite their service configuration while re-deploying it.

### The `EndPoint` element

The mandatory `Id` element defines the end-point name that identifies the service when calling a service API function. This name must be unique in its parent service scope.

The `Name` element is used to identify the service in error messages generated by the service module.

The `URL` element is mandatory in a service consumer configuration section. It defines the URL of the service end point to call to invoke the service.

### The `Hooks` element

That section defines services which are not produced or consumed with the service API, but which are invoked by other means. The end points defined in services defined in the hooks section are used with the *services:get-hook-address()* function which returns the associated URL. 

This section has been added as a key/value store for URLs which are manipulated by the application. In that case the key is the combination of the service name and end point name. This is useful for instance to generate links to embed in e-mail messages sent from the application. It allows to keep all the addresses pointing to external services or applications in one location.

### Extra features

#### The `Deploy` element

To be explained

Used to automatically invoke a service end point in deployment scripts, for instance to initialize extra inter-applications configuration.

#### The `Key`, `Keys` and `KeyRef` elements

To be explained

Used to identify a specific consumer of a service in a producer with multipe consumers.

## Service invocation

The most common pattern is an application A that invoking an application's B service to answer a client request. This service invocation is done server-side, from server to server. If you control both applications you can privatize the network communication between themselves, for instance hiding the application's ports with a forward proxy. 

You can also call a service client-side. In that case you use Javascript code to generate the XML service message into a string that you can POST with Ajax.

### Server-side XQuery

To use the service API import the service module :

    import module namespace services = "http://oppidoc.com/ns/services" at "{your-path-to}/lib/services.xqm";
    
#### Consumer calling a service endpoint

To call a service endpoint from your XQuery model use the function :

    let $result := services:post-to-service(service, endpoint, $payload, status)

where :

* *service* is the name of the service producer as recorded in `services.xml`
* *endpoint*  is the name of the end point as recorderd in `services.xml`
* *$payload* is the XML content to be send in the request
* *status* is the HTTP status code you expect to be returned by service invocation (e.g. "200" or "201"), any other status will throw an oppidum error

In case of success the result is the complete result as returned by the *httpclient:post* method, so the response payload may be wrapped itself into other data. This depends of the version of the *httpclient* module used by the service module.

In case of error you should get one of the following Oppidum errors :

* SERVICE-ERROR : when the producer returned an unexpected status code
* SERVICE-INTERNAL-ERROR : when the producer returned itself an Oppidum error
* SERVICE-NOT-RESPONDING : when service module could not establish connection with producer
* SERVICE-MALFORMED-URL : if the service URL could not be converted to an xs:anyURI type

#### Producer answering a service endpoint

Reciprocally to retrieve the XML payload data in the producer application use the following code in the XQuery model mapped to the end point URL :

    let $envelope := request:get-data()
    let $errors := services:validate(service, endpoint, $envelope)
    return
      if (empty($errors)) then
        let $payload := services:unmarshall($envelope)
        return ...
      else
        $errors

The call to *services:validate* ensures service invocation is conform with the service protocol. In particular it checks the authorization token. Do not forget to return the error to the service consumer so that the error can be traced.

### Client-side Javascript

You can also invoke a service from Javascript. For that purpose, if the service is protected with an authorization token, you need to transmit the token to the end user's browser page invoking the service. This may be insecure as it would allow somebody to still the token and submit service requests, so at least you should use an HTTPS request.

The rest of this section assumes you are using jQuery client-side and proposes a simple programming pattern.

To invoke a service from Javascript you can pre-fill server-side your **(X)HTML** page with a *data island* containing the service invocation envelope (see below *Implementation of the service procotol*) with the optional authorization token. You can call the *services:gen-envelope-for(service, endpoint, payload)* method to generate this XML message for you (including the optional authorization token) pre-filled with your XML data bound to a payload variable. For instance your Oppidum model can create a data island model data as this :

```xml
<DataIsland Id="my-ajax-template">
  { services:gen-envelope-for('service name', 'endpoint name', $payload }
</DataIsland>
```

data island which can be embedded in a page using this XSLT template : 

```xml
<xsl:template match="DataIsland">
  <script id="{@Id}" type="application/xml" style="display:none">
    <xsl:copy-of select="*"/>
  </script>
</xsl:template> 
```
    
Then in javascript you just just need to retrieve your data island content as text (with _$('#my-ajax-template").text()_) and post it with the $.ajax jQuery method, for instance with :

    $.ajax({
      url : ...service endpoint address...,
      type : 'post',
      async : false,
      data : $('#my-ajax-template").text(),
      contentType : "application/xml; charset=UTF-8",
      dataType : ...expected response format (e.g. 'xml' or 'json')...,
      cache : false,
      timeout : 50000,
      success : someSuccessCallback,
      error : someErrorCallback
    });

If you need to compute a dynamic payload client-side you can pre-fill your envelope with a place holder payload such as :

     <Fill>HERE</Fill>

then you can dynamically replace it client-side just before calling the ajax request :

    envelope = $('#my-ajax-template).text();
    payload  = envelope.replace('<Fill>HERE</Fill>', whatever);

Of course you are free to use other means to create the service invocation request and to send it with Ajax. All you need it to do is to create a request body conform with the XML message format of the service protocol.

## Implementation of the service procotol

The XML payload is wrapped into an XML envelope with the following structure :

```xml
<Service>
  <AuthorizationToken>REPLACE-WITH-YOUR-TOKEN</AuthorizationToken>
  <Payload><REPLACE-WITH-YOUR-PAYLOAD-CONTENT/></Payload>
</Service>
```

The authorization token is the token configured for the service endpoint in the Providers section of the service producer and in the Consumers section of the service consumer.

The services module does all the work necessary to insert and compare the autorization token, so you do not need to care for that. You may eventually need to manually create XML envelopes if you want to test a service provider using a command line tool such as curl or wget to send POST requests.

## Service module functions summary

The principal functions available in `lib/services.xqm` are the following ones.

Consumer related functions : 

* _services:post-to-service ( $service-name as xs:string, $end-point-name as xs:string, $payload as element()?, $expected as xs:string+ ) as element()?_ : calls a service server to server and returns its response content or an Oppidum error (see above the different error types)
* _services:gen-envelope-for( $service-name as xs:string?, $end-point-name as xs:string?, $payload as item()* ) as element()?*_ : pre-generate the XML message to embed in the page to call service from Javascript (see above a suggested Javascript pattern with jQuery)

Producer related functions : 

* _services:validate ( $service-name as xs:string, $end-point as xs:string, $submitted as item()? ) as element()?_ : verifies a service request and returns empty sequence or an Oppidum error
* _services:unmarshall( $submitted as element()? ) as element()*_ : returns submitted request payload

Utility function :

* _services:get-hook-address( $service as xs:string, $end-point as xs:string ) as xs:string_ : read the hooks key/value store to get a URL address string to insert somewhere

For a function detailed explanation please see its header comment.

## Testing the service procotol

The *Mapping simulator* tool of the *devel* branch of Oppidum implements a *SERVICE* button that you can use to generate an empty XML message envelope. You can complete it in the embedded editor and then send it to the current mapping entry using the *POST* button.

## Future enhancements

We are considering adding more security to service invocation by :

- integrating IP and/or port checking directly within the service module (and thus creating access rules based on IP and/or port in *services.xml*)
- implementing a nonce protcol for client-side Javascript invocation using generated tokens with a short live
